name: Deploy image to EC2

on:
  schedule:
    - cron: "0 */24 * * *"   # every 2 hours (UTC)
  workflow_dispatch:

concurrency:
  group: ec2-run
  cancel-in-progress: false

jobs:
  run:
    runs-on: ubuntu-latest
    timeout-minutes: 360
    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
      EC2_USER: ${{ secrets.EC2_USER }}
      CONTAINER_IMAGE: ${{ secrets.CONTAINER_IMAGE }}
      CONTAINER_NAME: my-python-job

    steps:
      - name: Configure AWS via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_ROLE_TO_ASSUME }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Ensure EC2 is running + get host (wait for SSH)
        id: ec2
        shell: bash
        run: |
          set -euo pipefail
          STATE=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].State.Name' --output text)
          if [ "$STATE" != "running" ]; then
            aws ec2 start-instances --instance-ids "$INSTANCE_ID" >/dev/null
            aws ec2 wait instance-running --instance-ids "$INSTANCE_ID"
          fi

          # Wait for both AWS status checks to pass
          aws ec2 wait instance-status-ok --instance-ids "$INSTANCE_ID"

          HOST=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].PublicDnsName' --output text)
          if [ -z "$HOST" ] || [ "$HOST" = "None" ]; then
            HOST=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          fi

          # Wait for SSH port to be open
          READY=0
          for i in {1..30}; do
            if timeout 3 bash -c ">/dev/tcp/$HOST/22" 2>/dev/null; then
              READY=1
              break
            fi
            sleep 5
          done
          if [ "$READY" -ne 1 ]; then
            echo "SSH port 22 not reachable on $HOST"; exit 1
          fi
          echo "host=$HOST" >> "$GITHUB_OUTPUT"

      - name: Create SSH key
        shell: bash
        run: |
          set -euo pipefail
          umask 077
          printf '%s' "${{ secrets.EC2_SSH_KEY }}" > key.pem
          sed -i 's/\r$//' key.pem
          chmod 600 key.pem

      - name: Build app.env
        shell: bash
        run: |
          set -euo pipefail
          umask 077
          cat > app.env <<'EOF'
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          SAFE_ROADS_API=${{ secrets.SAFE_ROADS_API }}
          HTTP_TIMEOUT=30
          G_TOKEN=${{ secrets.G_TOKEN }}
          EOF
          # Normalize line endings to avoid Docker env-file parse issues
          sed -i 's/\r$//' app.env
          # Presence check without printing the secret
          grep -n '^G_TOKEN=' app.env >/dev/null || { echo "G_TOKEN missing in app.env"; exit 1; }

      - name: Copy app.env to EC2 
        env:
          EC2_HOST: ${{ steps.ec2.outputs.host }}
        shell: bash
        run: |
          set -euo pipefail
          SSH_OPTS="-o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
            -o ServerAliveInterval=15 -o ServerAliveCountMax=60 \
            -o TCPKeepAlive=yes -o ConnectionAttempts=30 -o ConnectTimeout=10 \
            -i key.pem"
          ok=0
          for i in {1..5}; do
            if scp $SSH_OPTS app.env "$EC2_USER@${EC2_HOST}:~/app.env"; then
              ok=1; break
            fi
            sleep 5
          done
          if [ "$ok" -ne 1 ]; then
            echo "Failed to scp app.env to $EC2_HOST after retries"; exit 1
          fi

      - name: Run the deployment code
        env:
          EC2_HOST: ${{ steps.ec2.outputs.host }}
          CONTAINER_MEM: ${{ secrets.CONTAINER_MEM }}   # optional, e.g. "3g"
        shell: bash
        run: |
          set -euo pipefail
          SSH_OPTS="-o StrictHostKeyChecking=no -o IdentitiesOnly=yes \
            -o ServerAliveInterval=15 -o ServerAliveCountMax=60 \
            -o TCPKeepAlive=yes -o ConnectionAttempts=30 -o ConnectTimeout=10 \
            -i key.pem"
          ssh $SSH_OPTS "$EC2_USER@${EC2_HOST}" bash -se <<EOF
          set -euo pipefail

          ENV_FILE="\$HOME/app.env"
          test -f "\$ENV_FILE"
          grep -n '^G_TOKEN=' "\$ENV_FILE" >/dev/null || { echo "G_TOKEN missing in env file"; exit 1; }

          # Ensure Docker exists and is running (Ubuntu/Debian & Amazon Linux 2)
          if ! command -v docker >/dev/null 2>&1; then
            if [ -f /etc/os-release ] && grep -qi ubuntu /etc/os-release; then
              sudo apt-get update -y
              sudo apt-get install -y docker.io
            else
              # Amazon Linux 2 / RHEL family
              sudo amazon-linux-extras install -y docker || sudo yum install -y docker || sudo dnf install -y docker
            fi
          fi
          sudo systemctl enable --now docker || true
          sudo docker version || { echo "Docker not ready"; exit 1; }

          # Pull latest image
          sudo docker pull "${CONTAINER_IMAGE}"

          # Stop any previous container
          sudo docker rm -f "${CONTAINER_NAME}" >/dev/null 2>&1 || true

          # Optional memory cap if provided (e.g. 3g). This line is locally expanded by Actions:
          CONTAINER_MEM_VAL="${CONTAINER_MEM}"
          RUN_MEM_ARGS=()
          if [ -n "\$CONTAINER_MEM_VAL" ]; then
            RUN_MEM_ARGS+=(--memory "\$CONTAINER_MEM_VAL" --memory-swap "\$CONTAINER_MEM_VAL")
          fi

          # Run detached so we can stream logs and still get exit code
          CID=\$(sudo docker run -d --name "${CONTAINER_NAME}" \
            --env-file "\$ENV_FILE" \
            "\${RUN_MEM_ARGS[@]}" \
            "${CONTAINER_IMAGE}")
          echo "Container ID: \$CID"

          # Stream logs until exit, capture status
          set +e
          sudo docker logs -f "\$CID" &
          LOGSPID=\$!
          sudo docker wait "\$CID"
          WAIT_STATUS=\$?
          kill \$LOGSPID 2>/dev/null || true
          set -e

          # Inspect termination details
          OOM=\$(sudo docker inspect -f '{{.State.OOMKilled}}' "\$CID")
          EXIT=\$(sudo docker inspect -f '{{.State.ExitCode}}' "\$CID")
          FINISHED=\$(sudo docker inspect -f '{{.State.FinishedAt}}' "\$CID")
          echo "Container finished at \$FINISHED with exit \$EXIT (OOMKilled=\$OOM)"

          echo "==== Recent kernel messages (OOM?) ===="
          journalctl -k --since "-1h" | egrep -i 'oom|out of memory' || echo "No OOM messages in last hour."

          # Fail the job if the container failed
          if [ "\$EXIT" -ne 0 ]; then
            echo "Container exit code: \$EXIT"
            exit \$EXIT
          fi
          EOF

      - name: Cleanup local artifacts
        if: always()
        shell: bash
        run: |
          rm -f key.pem app.env

      - name: Stop EC2 to save costs
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          aws ec2 stop-instances --instance-ids "$INSTANCE_ID" >/dev/null
          aws ec2 wait instance-stopped --instance-ids "$INSTANCE_ID"
